string _procName;
int    _pidOffset;
int    _nameOffset;

## guestload --
## guestloadstr --
##   Checked wrappers around getguest that return 0 for reads of the null
##   page.
int
guestload(int addr)
{
   _rval = 0;
   if (addr >= 4096) { # null reads back null
      _rval = getguest(addr);
   }
   return _rval;
}

int
guestload32(int addr)
{
   return guestload(addr) & 0xffffffff;
}

void
guestloadstr(string str, int addr)
{
   if (addr < 4096) {
      sprintf(str, "<NULL:%p>", addr);
   } else {
      getgueststr(str, addr);
   }
}

## curthrptr --
##   Return pointer to kernel thread-private data for the current process
##   on the current VCPU. This might be either GSBASE or KERNELGSBASE;
##   testing the CPL isn't *quite* right, because there's a short window
##   immediately after the hardware syscall where the right value is still
##   in KERNELGSBASE.
int
curthrptr()
{
   if (!_pidOffset) {
      _pidOffset = offatret("sys_getpid");
      _nameOffset = offatstrcpy("get_task_comm");
   }
   return RSP & 0xfffff000;
}

string
curprocname()
{
   guestloadstr(_procName, _nameOffset + guestload32(curthrptr()));
   return _procName;
}

int
curpid()
{
   return guestload32(_pidOffset + guestload32(curthrptr()));
}
